
/*================================================================*/ 
/* 
  JavaCup Specification for the JavaCup Specification Language
  by Scott Hudson, GVU Center, Georgia Tech, August 1995
  and Frank Flannery, Department of Computer Science, Princeton Univ,
  July 1996
  Bug Fixes: C. Scott Ananian, Dept of Electrical Engineering, Princeton
  University, October 1996. [later Massachusetts Institute of Technology]


  This JavaCup specification is used to implement JavaCup itself.
  It specifies the parser for the JavaCup specification language.
  (It also serves as a reasonable example of what a typical JavaCup
  spec looks like).

  The specification has the following parts:
    Package and import declarations
      These serve the same purpose as in a normal Java source file
      (and will appear in the generated code for the parser). In this 
      case we are part of the java_cup package and we import both the
      java_cup runtime system and Hashtable from the standard Java
      utilities package.

    Action code
      This section provides code that is included with the class encapsulating
      the various pieces of user code embedded in the grammar (i.e., the
      semantic actions).  This provides a series of helper routines and
      data structures that the semantic actions use.

    Parser code    
      This section provides code included in the parser class itself.  In
      this case we override the default error reporting routines.

    Init with and scan with 
      These sections provide small bits of code that initialize, then 
      indicate how to invoke the scanner.

    Symbols and grammar
      These sections declare all the terminal and non terminal symbols 
      and the types of objects that they will be represented by at runtime,
      then indicate the start symbol of the grammar (), and finally provide
      the grammar itself (with embedded actions).

    Operation of the parser
      The parser acts primarily by accumulating data structures representing
      various parts of the specification.  Various small parts (e.g., single
      code strings) are stored as static variables of the emit class and
      in a few cases as variables declared in the action code section.  
      Terminals, non terminals, and productions, are maintained as collection
      accessible via static methods of those classes.  In addition, two 
      symbol tables are kept:  
	symbols   maintains the name to object mapping for all symbols
	non_terms maintains a separate mapping containing only the non terms

      Several intermediate working structures are also declared in the action
      code section.  These include: rhs_parts, rhs_pos, and lhs_nt which
      build up parts of the current production while it is being parsed.
	
  Author(s)
    Scott Hudson, GVU Center, Georgia Tech.
    Frank Flannery, Department of Computer Science, Princeton Univ.
    C. Scott Ananian, Department of Electrical Engineering, Princeton Univ.

  Revisions
    v0.9a   First released version                     [SEH] 8/29/95
    v0.9b   Updated for beta language (throws clauses) [SEH] 11/25/95
    v0.10a  Made many improvements/changes. now offers:
              return value
              left/right positions and propagations
              cleaner label references
              precedence and associativity for terminals
              contextual precedence for productions
              [FF] 7/3/96
    v0.10b  Fixed %prec directive so it works like it's supposed to.
              [CSA] 10/10/96
    v0.10g   Added support for array types on symbols.
              [CSA] 03/23/98
    v0.10i  Broaden set of IDs allowed in multipart_id and label_id so
            that only java reserved words (and not CUP reserved words like
            'parser' and 'start') are prohibited.  Allow reordering of
	    action code, parser code, init code, and scan with sections,
	    and made closing semicolon optional for these sections.
	    Added 'nonterminal' as a terminal symbol, finally fixing a
	    spelling mistake that's been around since the beginning.
	    For backwards compatibility, you can still misspell the
	    word if you like.
*/
/*================================================================*/ 

package java_cup;
import java_cup.runtime.*;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.Iterator;
/*----------------------------------------------------------------*/ 

option java15, compact_red, interface, newpositions;

action code {:
  /** table of declared symbols -- contains production parts indexed by name */
  private HashMap<String, symbol> symbols = new HashMap<String, symbol>();

  private ArrayList<terminal> terminals = new ArrayList<terminal>();
  private ArrayList<non_terminal> non_terminals = new ArrayList<non_terminal>();
  private ArrayList<production> productions = new ArrayList<production>();

  /** declared start non_terminal */
  private non_terminal start_nt = null;

  /** left hand side non terminal of the current production */
  private non_terminal lhs_nt;

  {
    /* declare "error" and "EOF" as a terminal */
    terminals.add(terminal.error);
    terminals.add(terminal.EOF);
    symbols.put("error", terminal.error);

    /* declare start non terminal */
    non_terminals.add(non_terminal.START_nt);
  }  

  /** Current symbol type */
  String _cur_symbol_type;

  /** Current precedence number */
  int _cur_prec = 0;

  /** Current precedence side */
  int _cur_side = assoc.no_prec;

  /** update the precedences we are declaring */
  protected void update_precedence(int p)
    {
      _cur_side = p;
      _cur_prec++;
    }
  
  private terminal get_term(String id)
    {
      symbol sym = symbols.get(id);

      /* if it wasn't declared of the right type, emit a message */
      if (!(sym instanceof terminal))
	{
	  if (ErrorManager.getManager().getErrorCount() == 0)
	    ErrorManager.getManager().emit_warning("Terminal \"" + id + 
	    "\" has not been declared");
	  return null;
	}
      return (terminal)sym;
    }
  
  private non_terminal get_nonterm(String id)
    {
      symbol sym = symbols.get(id);

      /* if it wasn't declared of the right type, emit a message */
      if (!(sym instanceof non_terminal))
	{
	  if (ErrorManager.getManager().getErrorCount() == 0)
	    ErrorManager.getManager().emit_warning("Non-terminal \"" + id + 
	    "\" has not been declared");
	  return null;
	}
      return (non_terminal)sym;
    }

  /** set start non terminal symbol */
  private void set_start_symbol(non_terminal nt)
    {
      start_nt = nt;
      /* build a special start production */
      symbol_part[] rhs = new symbol_part[2];
      action_part action = null;
      if (start_nt.stack_type() != null)
	{
	  rhs[0] = new symbol_part(start_nt, "start_val");
	  action = new action_part("RESULT = start_val;");
	}
      else
	rhs[0] = new symbol_part(start_nt);
      rhs[1] = new symbol_part(terminal.EOF);
      parser.main.start_production = 
	  new production(0, non_terminal.START_nt, rhs, action, null);
      productions.add(parser.main.start_production);
      non_terminal.START_nt.note_use();
    }
  
  /* . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */

  private int next_nt = 0; 
  non_terminal create_anon_nonterm(String type) 
    {
        non_terminal nt = new non_terminal
        	("NT$" + next_nt++, type, non_terminals.size());
        non_terminals.add(nt);
        return nt;
    }

  /**
   * Create a production. Takes a LHS non terminal, a list of
   * RHS parts (including terminals, non terminals, and actions) and a
   * precedence.  We factor out embedded actions into separate action_production
   * using temporary non-terminals.  Adjacent actions are merge immediately.
   * 
   * <p>Factoring out of actions is accomplished by creating new "hidden" non
   * terminals. For example if the production was originally:</p>
   * 
   * <pre>
   *    A ::= B {action} C D
   * </pre>
   * 
   * then it is factored into two productions:
   * 
   * <pre>
   *    A ::= B X C D
   *    X ::= {action}
   * </pre>
   * 
   * (where X is a unique new non terminal). This has the effect of placing all
   * actions at the end where they can be handled as part of a reduce by the
   * parser.
   */
  private void build_production(non_terminal lhs_sym, ArrayList<production_part> rhs_parts, terminal precedence)
    {
      int i;

      /* make sure we have a valid left-hand-side */
      assert lhs_sym != null : "Attempt to construct a production with a null LHS";

      /* count use of lhs */
      lhs_sym.note_use();
      if (precedence != null)
	precedence.note_use();

      /* merge adjacent actions (if any) */
      Iterator<production_part> it = rhs_parts.iterator();
      action_part prev_action = null;
      while (it.hasNext())
	{
	  production_part part = it.next();
	  if (part instanceof action_part)
	    {
	      if (prev_action != null)
		{
		  prev_action.add_code_string(((action_part)part).code_string());
		  it.remove();
		}
	      else
		prev_action = (action_part) part;
	    }
	  else
	    prev_action = null;
	}
      
      action_part action = null;
      /* strip off any trailing action */
      if (rhs_parts.size() > 0 && rhs_parts.get(rhs_parts.size() - 1).is_action())
	{
	  action = (action_part) rhs_parts.remove(rhs_parts.size()-1);
	}

      /* allocate and copy over the right-hand-side */
      symbol_part[] rhs = new symbol_part[rhs_parts.size()];
      /* count use of each rhs symbol */
      for (i = 0; i < rhs.length; i++)
	{
	  production_part prod = rhs_parts.get(i);
	  if (prod.is_action())
	    {
	      /* create a new non terminal for the action production */
	      non_terminal new_nt = create_anon_nonterm(lhs_sym.stack_type()); 
	      new_nt.is_embedded_action = true;
	      new_nt.note_use();
	      rhs[i] = new symbol_part(new_nt);
	    }
	  else
	    {
	      rhs[i] = (symbol_part) prod;
	    }
	}
      
      /* put the production in the production list of the lhs non terminal */
      production prod = new production(productions.size(), lhs_sym, rhs, action, precedence);
      productions.add(prod);
      int last_act_loc = -1;
      for (i = 0; i < rhs.length; i++)
	{
	  production_part part = rhs_parts.get(i);
	  if (part.is_action())
	    {
	      production actprod = new action_production
	      	(productions.size(), prod, (non_terminal) rhs[i].the_symbol(), 
	      	    (action_part) part, i, last_act_loc);
	      productions.add(actprod);
	      last_act_loc = i;
	    }
	}
    }
:};

/*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */ 

parser code {:
  Main main;
  emit emit;
  
 /* override error routines */
  protected Lexer lexer;
  public void report_fatal_error(
    String   message,
    Object   info)
    {
      done_parsing();
      if (info instanceof Symbol) ErrorManager.getManager().emit_fatal(message+ "\nCan't recover from previous error(s), giving up.",(Symbol)info);
      else ErrorManager.getManager().emit_fatal(message + "\nCan't recover from previous error(s), giving up.",cur_token);
      System.exit(1);
    }

    public void report_error(String message, Object info)
    {
      if (info instanceof Symbol)
         ErrorManager.getManager().emit_error(message,(Symbol)info);
      else
         ErrorManager.getManager().emit_error(message,cur_token);
    }
:};

/*---------------------------------------------------------------- */

init with {: 
    ComplexSymbolFactory f = new ComplexSymbolFactory();
    symbolFactory = f;
    lexer = new Lexer(f); 
:}
scan with {: 
    return lexer.next_token(); 
:};

/*----------------------------------------------------------------*/ 

terminal
  PACKAGE, IMPORT, CODE, ACTION, PARSER, TERMINAL, NON, INIT, SCAN, WITH, 
  START, SEMI, COMMA, STAR, DOT, COLON, COLON_COLON_EQUALS, BAR, PRECEDENCE,
  LEFT, RIGHT, NONASSOC, PERCENT_PREC, LBRACK, RBRACK, NONTERMINAL, GT, LT,
  QUESTION, SUPER, EXTENDS, EQUALS, OPTION;

terminal String  ID, CODE_STRING;

non terminal
  package_spec, import_list, parser_spec,
  option_spec, option_list, option_, action_code_part, 
  code_parts, code_part, opt_semi, non_terminal,
  parser_code_part, symbol_list, start_spec, production_list, 
  import_spec, init_code, scan_code, symbol, 
  term_name_list, non_term_name_list, production, 
  new_term_id, new_non_term_id, rhs_list, rhs, empty,
  precedence_list, preced, assoc, precterminal_list, precterminal_id,
  declares_term, declares_non_term;
  
non terminal Grammar spec;

non terminal String  symbol_id, label_id, opt_label,
                     robust_id, typearglist, typeargument, wildcard;
non terminal StringBuilder multipart_id, import_id, type_id;
non terminal terminal term_id;

non terminal production_part prod_part;
non terminal ArrayList<production_part> prod_part_list;
non terminal symbol prod_precedence; 

/*----------------------------------------------------------------*/ 

start with spec;

/*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */ 

spec ::= 
	package_spec
	import_list
	code_parts
	symbol_list
	precedence_list
	start_spec
	production_list
        {: RESULT = new Grammar(terminals, non_terminals, productions); :}
	|
	/* error recovery assuming something went wrong before symbols 
	   and we have TERMINAL or NON TERMINAL to sync on.  if we get
	   an error after that, we recover inside symbol_list or 
	   production_list 
	*/
	error 
	symbol_list
	precedence_list
	start_spec
	production_list
        {: RESULT = new Grammar(terminals, non_terminals, productions); :}
	;

/*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */ 

package_spec ::= 
	PACKAGE
	multipart_id:id
	{:
	  /* save the package name */
	  parser.main.setOption("package", id.toString());
	:}
	SEMI
	|
	empty
	;

/*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */ 

import_list ::=
	import_list
	import_spec
	|
	empty
	;

/*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */ 

import_spec ::=
	IMPORT 
	import_id:id 
	SEMI
	{: 
	  /* save this import on the imports list */
	  parser.emit.import_list.add(id.toString());
	:}
	;


// allow any order; all parts are optional. [CSA, 23-Jul-1999]
// (we check in the part action to make sure we don't have 2 of any part)
code_part ::=
    option_spec | parser_spec |
	action_code_part | parser_code_part | init_code | scan_code ;
code_parts ::= 
	| code_parts code_part;

/*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */ 

parser_spec ::= 
	  PARSER multipart_id:name SEMI
         {: parser.main.setOption("parser", name.toString()); :}
	| PARSER multipart_id:name LT typearglist:types GT SEMI
         {: parser.main.setOption("parser", name.toString());
	    parser.main.setOption("typearg", types.toString()); :}
       	;


option_spec ::= OPTION option_list SEMI;
option_list ::= option_list COMMA option_ | option_;
option_ ::= robust_id:opt {: parser.main.setOption(opt); :} 
	| robust_id:opt EQUALS robust_id:val
          {: parser.main.setOption(opt, val); :};
/*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */ 

action_code_part ::= 
	ACTION CODE CODE_STRING:user_code opt_semi
	{:
	  if (parser.emit.action_code!=null)
	    ErrorManager.getManager().emit_warning("Redundant action code (skipping)");
	  else /* save the user included code string */
	    parser.emit.action_code = user_code;
	:}
	;

/*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */ 

parser_code_part ::= 
	PARSER CODE CODE_STRING:user_code opt_semi
	{:
	  if (parser.emit.parser_code!=null)
	    ErrorManager.getManager().emit_warning("Redundant parser code (skipping)");
	  else /* save the user included code string */
	    parser.emit.parser_code = user_code;
	:}
	;

/*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */ 

init_code ::= 
	INIT WITH CODE_STRING:user_code opt_semi
	{: 
	  if (parser.emit.init_code!=null)
	    ErrorManager.getManager().emit_warning("Redundant init code (skipping)");
	  else /* save the user code */
	    parser.emit.init_code = user_code;
	:}
	;

/*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */ 

scan_code ::=
	SCAN WITH CODE_STRING:user_code opt_semi
	{: 
	  if (parser.emit.scan_code!=null)
	    ErrorManager.getManager().emit_warning("Redundant scan code (skipping)");
	  else /* save the user code */
	    parser.emit.scan_code = user_code;
	:}
	;

/*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */ 

symbol_list ::= symbol_list symbol | symbol;

/*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */ 

symbol ::= 
	TERMINAL
	type_id:id {: _cur_symbol_type = id.toString(); :}	
	declares_term  {: _cur_symbol_type = null; :}
	|
	TERMINAL
	declares_term
	|
	non_terminal
	type_id:id  {: _cur_symbol_type = id.toString(); :}
	declares_non_term  {: _cur_symbol_type = null; :}
	|
	non_terminal
	declares_non_term
	|
	/* error recovery productions -- sync on semicolon */

	TERMINAL
	error
	SEMI  {: _cur_symbol_type = null; :}
	|
	non_terminal
	error
	SEMI  {: _cur_symbol_type = null; :}
	;

/*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */ 

declares_term ::=
	term_name_list
	SEMI
	;
/*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */ 

declares_non_term ::=
	non_term_name_list
	SEMI
	;
/*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */ 

term_name_list ::= term_name_list COMMA new_term_id | new_term_id;

/*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */ 

non_term_name_list ::=
	non_term_name_list
	COMMA
	new_non_term_id
	|
	new_non_term_id
	;

/*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */ 

precedence_list ::= precedence_list preced | empty; 

/*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */ 

preced ::= PRECEDENCE assoc precterminal_list SEMI;

assoc ::= LEFT     {: update_precedence(assoc.left); :}
        | RIGHT    {: update_precedence(assoc.right); :}
        | NONASSOC {: update_precedence(assoc.nonassoc); :}
        ;
      
/*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */ 

precterminal_list ::= precterminal_list COMMA precterminal_id
	|
	precterminal_id
	;

/*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */ 

precterminal_id ::= term_id:term
	{:	
	  term.set_precedence(_cur_side, _cur_prec);
	:};
	  
/*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */ 

term_id ::= symbol_id:sym
        {: RESULT = get_term(sym); :};

/*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */ 

start_spec ::= 
	START WITH symbol_id:start_name SEMI 
	{: non_terminal nt = get_nonterm(start_name);
	   if (nt != null) 
	     set_start_symbol(nt); 
	:}
	|
	empty
	;

/*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */ 

production_list ::= production_list production | production;

/*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */ 

production ::=
	symbol_id:lhs_id
	{:
	  /* lookup the lhs nt */
	  lhs_nt = get_nonterm(lhs_id);
	:}
	COLON_COLON_EQUALS
	rhs_list
	SEMI
	|
	error
	{: ErrorManager.getManager().emit_error("Syntax Error"); :}
	SEMI
	;

/*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */ 

rhs_list ::= rhs_list BAR rhs | rhs;

/*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */

prod_precedence ::= PERCENT_PREC term_id:term
	{: RESULT = term; :}
	| empty {: RESULT = null; :};
	      

rhs ::= 
	prod_part_list:rhs prod_precedence:precsym 
	{:
	  if (lhs_nt != null) 
	    {
	      /* if we have no start non-terminal declared and this is 
		 the first production, make its lhs nt the start_nt 
		 and build a special start production for it. */
	      if (start_nt == null)
		{
		  set_start_symbol(lhs_nt);
		}

	      /* build the production */
	      build_production(lhs_nt, rhs, (terminal) precsym);
	    }
	:}
	;

/*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */ 

prod_part_list ::= prod_part_list:list prod_part:prod
	{: RESULT = list; if (prod != null) RESULT.add(prod); :}
      | empty {: RESULT = new ArrayList<production_part>(); :}
      ;

/*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */ 

prod_part ::=
	symbol_id:symid opt_label:labid
	{: 
	  /* try to look up the id */
	  symbol symb = symbols.get(symid);

	  /* if that fails, symbol is undeclared */
	  if (symb == null)
	    {
	      if (ErrorManager.getManager().getErrorCount() == 0)
	        ErrorManager.getManager().emit_error("java_cup.runtime.Symbol \"" + symid + 
			       "\" has not been declared");
	      RESULT = null;
	    }
	  else
	    {
	      /* add a labeled production part */
	      RESULT = new symbol_part(symb, labid);
	    }
	:}
	|
	CODE_STRING:code_str
	{: 
	  /* add a new production part */
	  RESULT = new action_part(code_str);
	:}
	;

/*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */ 

opt_label ::=
	COLON label_id:labid
	{: RESULT = labid; :}
	|
	empty
	{: RESULT = null; :}
	;

/*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */ 

multipart_id ::=
	multipart_id:id DOT robust_id:another_id
	{: id.append('.').append(another_id); RESULT=id; :}
        |
	robust_id:an_id
	{: RESULT = new StringBuilder(an_id); :}
	;
/*. . . . . . . . . . . .TUM CHANGES. . . . . . . . . . . . . . . */


typearglist ::= 
            typeargument:arg
            {: RESULT = arg; :}
            | typearglist:list COMMA typeargument:arg
            {: RESULT = list + "," + arg; :}
            ;

typeargument ::=
              type_id:id
              {: RESULT = id.toString(); :}
              | wildcard:w
              {: RESULT = w; :}
              ;

wildcard ::=
         QUESTION
         {: RESULT = "?"; :}
         | wildcard:w EXTENDS type_id:id
         {: RESULT = w + " extends "+id; :}
         | wildcard:w SUPER type_id:id
         {: RESULT = w + " super "+id; :}
         ;

/*. . . . . . . . . . .END TUM CHANGES. . . . . . . . . . . . . . */ 


/*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */ 

import_id ::= 
	multipart_id:id DOT STAR
	{: id.append(".*"); RESULT = id; :}
	|
	multipart_id:id {: RESULT = id; :}
	;

/*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */ 

type_id ::= multipart_id:id {: RESULT = id; :}
	| type_id:id LBRACK RBRACK
	{: id.append("[]"); RESULT = id; :}
	|multipart_id:id 
        LT typearglist:types GT
         {: id.append('<').append(types).append('>');
            RESULT=id; :}
       	;

/*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */ 

new_term_id ::= 
	symbol_id:term_id 
	{: 
	  /* see if this terminal has been declared before */
	  if (symbols.get(term_id) != null)
	    {
	      /* issue a message */
	      ErrorManager.getManager().emit_error("Symbol \"" + term_id + 
			   "\" has already been declared");
	    }
	  else
	    {
	      /* build a production_part and put it in the table */
	      terminal term = new terminal(term_id, _cur_symbol_type, terminals.size());
	      terminals.add(term);
	      symbols.put(term_id, term);
	    }
	:}
	;

/*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */ 

new_non_term_id ::=
	symbol_id:non_term_id
	{: 
	  /* see if this non terminal has been declared before */
	  if (symbols.get(non_term_id) != null)
	    {
	      /* issue a message */
	      ErrorManager.getManager().emit_error( "Symbol \"" + non_term_id + 
			                      "\" has already been declared");
	    }
	  else
	    {
	      /* build the non terminal object */
              non_terminal this_nt = 
		new non_terminal(non_term_id, _cur_symbol_type, non_terminals.size());
	      non_terminals.add(this_nt);

	      /* put it in the symbols table */ 
	      symbols.put(non_term_id, this_nt);
	    }
	:}
	;

/*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */ 

symbol_id ::=
	ID:the_id
	{: RESULT = the_id; :}
	| SUPER		{: RESULT = "super"; :}
	| EXTENDS	{: RESULT = "extends"; :}
	;

/*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */ 

label_id ::= 
	robust_id:the_id
	{: RESULT = the_id; :}
	;

/*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */ 

robust_id ::= /* all ids that aren't reserved words in Java */
	ID:the_id	{: RESULT = the_id; :}
	/* package is reserved. */
	/* import is reserved. */
	| OPTION	{: RESULT = "option"; :}
	| CODE		{: RESULT = "code"; :}
	| ACTION	{: RESULT = "action"; :}
	| PARSER	{: RESULT = "parser"; :}
	| TERMINAL	{: RESULT = "terminal"; :}
	| NON		{: RESULT = "non"; :}
	| NONTERMINAL   {: RESULT = "nonterminal"; :}
	| INIT		{: RESULT = "init"; :}
	| SCAN		{: RESULT = "scan"; :}
	| WITH		{: RESULT = "with"; :}
	| START		{: RESULT = "start"; :}
	| PRECEDENCE	{: RESULT = "precedence"; :}
	| LEFT		{: RESULT = "left"; :}
	| RIGHT		{: RESULT = "right"; :}
	| NONASSOC	{: RESULT = "nonassoc"; :}
	| error
	{:
		ErrorManager.getManager().emit_error("Illegal use of reserved word");
		RESULT="ILLEGAL";
	:}
	;

/*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */ 

non_terminal ::= NON TERMINAL | NONTERMINAL;

/*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */ 

opt_semi ::= /* nothing */
	| SEMI;

/*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */ 

empty ::= /* nothing */;

/*----------------------------------------------------------------*/ 

