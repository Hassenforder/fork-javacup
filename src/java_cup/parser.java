
//----------------------------------------------------
// The following code was generated by CUP v0.12joho 20081109
// Sat Nov 15 15:47:39 CET 2008
//----------------------------------------------------

package java_cup;

import java_cup.runtime.*;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.Iterator;

/** CUP v0.12joho 20081109 generated parser.
  * @version Sat Nov 15 15:47:39 CET 2008
  */
public class parser extends java_cup.runtime.LRParser {

  /** Default constructor. */
  public parser() {super();}

  /** Constructor which sets the default scanner. */
  public parser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public parser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}
  /** Return action table */
  protected String[] action_table() { 
    return new String[] {
    "\346\000\002\043\007\043\005\001\004\062\000" +
    "\001\001\002\002\002\001\020\003\011\001\011" +
    "\001\011\001\011\001\011\001\011\001\010\000" +
    "\010\002\003\003\003\006\004\003\005\003\005" +
    "\001\006\001\006\003\007\004\014\004\021\004" +
    "\022\004\015\002\015\001\023\004\063\000\023" +
    "\002\023\004\064\000\023\002\023\003\023\003" +
    "\041\002\042\002\024\003\024\001\025\003\025" +
    "\001\034\002\034\001\035\004\036\001\036\001" +
    "\036\001\037\003\037\001\040\001\056\001\016" +
    "\004\016\001\017\002\017\001\026\005\065\000" +
    "\026\003\066\000\031\003\031\001\061\002\061" +
    "\001\032\002\060\002\060\001\057\002\057\001" +
    "\046\002\046\001\053\003\053\001\050\001\050" +
    "\003\051\001\051\001\052\001\052\003\052\003" +
    "\054\003\054\001\055\001\055\003\055\004\027" +
    "\001\030\001\044\001\044\001\044\001\045\001" +
    "\047\001\047\001\047\001\047\001\047\001\047" +
    "\001\047\001\047\001\047\001\047\001\047\001" +
    "\047\001\047\001\047\001\047\001\047\001\047" +
    "\001\013\002\013\001\012\000\012\001\033\000" +
    "\270\270\366\270\270\270\302\270\270\270\270" +
    "\270\270\270\270\270\270\270\270\270\270\270" +
    "\270\270\270\270\270\272\270\300\270\u0136\u0178" +
    "\332\270\u01ba\272\u01cc\270\u020a\270\270\270\270" +
    "\300\304\332\270\270\274\272\270\270\310\270" +
    "\314\276\270\270\376\270\270\270\270\334\354" +
    "\374\270\270\u011a\u024a\270\270\270\u028a\376\372" +
    "\362\270\u02ca\270\350\u0114\u0128\270\270\u0154\270" +
    "\270\u0158\u017e\u0118\354\u010e\u0114\u0198\u01d2\u0122\u0156" +
    "\270\u013c\270\u030a\270\270\u01ce\270\u0174\u016a\270" +
    "\270\270\270\270\270\270\270\u0226\u01b6\270\270" +
    "\270\u01fc\u01ba\u01d4\u01de\u022a\270\u034a\u01e0\u038a\270" +
    "\u03ca\270\u040a\270\u044a\u048a\u01e0\u01ee\270\270\270" +
    "\270\u0212\u01f4\270\270\270\270\u0246\u0214\270\270" +
    "\270\270\u01f2\u020c\270\270\u023c\270\270\u022a\u027c" +
    "\270\270\u028a\270\270\u024c\270\270\u0268\270\270" +
    "\270\270\270\270\u04ca\270\270\270\270\u0514\000" +
    "\000\346\014\000\000\012\316\302\314\304\310" +
    "\226\320\326\332\334\274\330\300\276\306\324" +
    "\322\312\020\040\002\000\074\000\000\346\340" +
    "\000\000\000\016\000\336\130\266\110\274\000" +
    "\252\262\270\334\106\102\124\000\260\334\100" +
    "\134\072\346\224\010\024\034\000\000\000\030" +
    "\026\346\000\036\032\042\000\000\250\000\120" +
    "\000\114\000\000\000\116\112\000\132\160\000" +
    "\000\000\000\000\000\346\000\300\000\054\056" +
    "\022\000\126\264\000\240\236\234\230\254\104" +
    "\122\076\170\164\174\000\000\144\140\142\000" +
    "\342\342\342\000\044\000\342\000\050\000\246" +
    "\000\256\000\000\000\000\162\150\154\152\000" +
    "\000\070\344\062\066\000\000\064\052\060\232" +
    "\242\244\346\172\000\136\156\000\346\200\212" +
    "\000\146\046\346\216\204\000\206\210\166\346" +
    "\214\222\000\202\176\220\272\000\013\004\067" +
    "\000\003\000\346\032\115\000\346\000\346\000" +
    "\346\000\346\000\346\000\346\034\117\005\077" +
    "\005\071\043\171\060\237\006\105\053\264\053" +
    "\264\054\233\054\231\064\247\064\245\066\251" +
    "\040\077\040\071\061\241\000\346\067\241\077" +
    "\267\100\271\001\041\005\103\055\105\000\346" +
    "\001\047\001\021\001\025\001\053\001\027\001" +
    "\023\001\017\001\033\001\057\040\103\101\273" +
    "\055\235\072\265\112\311\113\313\120\333\001" +
    "\055\001\035\001\045\001\037\072\263\104\077" +
    "\104\071\001\061\132\363\114\123\114\137\133" +
    "\365\036\141\114\317\001\051\001\043\036\047" +
    "\036\021\036\025\036\053\036\027\036\023\036" +
    "\017\036\033\036\057\104\103\121\123\121\137" +
    "\134\367\130\347\121\317\135\371\036\055\036" +
    "\035\036\045\036\037\122\123\122\137\140\u0101" +
    "\036\061\122\317\141\u0105\141\u0103\036\123\036" +
    "\137\037\155\036\051\036\127\143\u0107\037\047" +
    "\037\021\037\025\037\053\037\027\037\023\037" +
    "\017\037\033\037\057\125\123\125\137\130\123" +
    "\130\137\125\317\153\241\130\317\037\055\037" +
    "\035\037\045\037\037\131\357\131\361\131\355" +
    "\037\061\136\265\152\u0111\152\u010f\037\123\037" +
    "\137\042\041\037\051\037\127\136\263\042\047" +
    "\042\021\042\025\042\053\042\027\042\023\042" +
    "\017\042\033\042\057\172\u0125\044\201\044\213" +
    "\044\077\044\071\044\203\044\177\042\055\042" +
    "\035\042\045\042\037\150\u010b\137\375\173\u0125" +
    "\042\061\137\105\165\123\165\137\174\u0125\200" +
    "\u0125\165\317\042\051\042\043\044\103\211\u013b" +
    "\150\u010d\212\u013d\046\041\137\377\220\u0143\044" +
    "\223\046\047\046\021\046\025\046\053\046\027" +
    "\046\023\046\017\046\033\046\057\233\241\164" +
    "\347\164\006\175\347\217\u0141\217\u013f\226\u010b" +
    "\046\055\046\035\046\045\046\037\171\123\171" +
    "\137\234\241\046\061\171\317\242\u0151\225\347" +
    "\225\004\105\041\226\u0145\046\051\046\043\105" +
    "\301\105\021\105\025\105\053\105\027\105\023" +
    "\105\017\105\033\105\057\164\123\164\137\175" +
    "\123\175\137\164\317\251\u0167\175\317\105\055" +
    "\105\035\105\045\105\037\237\123\237\137\270" +
    "\000\105\061\237\317\225\123\225\137\270\000" +
    "\111\041\225\317\105\051\105\043\111\047\111" +
    "\021\111\025\111\053\111\027\111\023\111\017" +
    "\111\033\111\057\246\u015f\254\123\254\137\270" +
    "\000\243\u0159\254\317\246\u0161\111\055\111\035" +
    "\111\045\111\037\243\123\243\137\270\000\111" +
    "\061\243\317\243\u0155\270\000\270\000\116\041" +
    "\270\000\111\051\111\043\116\047\116\021\116" +
    "\025\116\053\116\027\116\023\116\017\116\033" +
    "\116\057\270\000\270\000\270\000\270\000\270" +
    "\000\270\000\270\000\116\055\116\035\116\045" +
    "\116\037\270\000\270\000\270\000\116\061\270" +
    "\000\270\000\116\323\270\000\145\041\270\000" +
    "\116\051\116\043\145\047\145\021\145\025\145" +
    "\053\145\027\145\023\145\017\145\033\145\057" +
    "\270\000\270\000\145\u0109\270\000\270\000\270" +
    "\000\270\000\145\055\145\035\145\045\145\037" +
    "\270\000\270\000\270\000\145\061\270\000\270" +
    "\000\270\000\270\000\177\041\270\000\145\051" +
    "\145\043\177\047\177\021\177\025\177\053\177" +
    "\027\177\023\177\017\177\033\177\057\270\000" +
    "\270\000\270\000\270\000\270\000\270\000\270" +
    "\000\177\055\177\035\177\045\177\037\270\000" +
    "\270\000\270\000\177\061\270\000\270\000\177" +
    "\323\270\000\201\041\270\000\177\051\177\043" +
    "\201\047\201\021\201\025\201\053\201\027\201" +
    "\023\201\017\201\033\201\057\270\000\270\000" +
    "\270\000\270\000\270\000\270\000\270\000\201" +
    "\055\201\035\201\045\201\037\270\000\270\000" +
    "\270\000\201\061\270\000\270\000\270\000\270" +
    "\000\203\041\270\000\201\051\201\043\203\047" +
    "\203\021\203\025\203\053\203\027\203\023\203" +
    "\017\203\033\203\057\270\000\270\000\270\000" +
    "\270\000\270\000\270\000\270\000\203\055\203" +
    "\035\203\045\203\037\270\000\270\000\270\000" +
    "\203\061\270\000\270\000\270\000\270\000\205" +
    "\041\270\000\203\051\203\043\205\047\205\021" +
    "\205\025\205\053\205\027\205\023\205\017\205" +
    "\033\205\057\270\000\270\000\270\000\270\000" +
    "\270\000\270\000\270\000\205\055\205\035\205" +
    "\045\205\037\270\000\270\000\270\000\205\061" +
    "\270\000\270\000\205\323\270\000\207\041\270" +
    "\000\205\051\205\043\207\047\207\021\207\025" +
    "\207\053\207\027\207\023\207\017\207\033\207" +
    "\057\270\000\270\000\270\000\270\000\270\000" +
    "\270\000\270\000\207\055\207\035\207\045\207" +
    "\037\270\000\270\000\270\000\207\061\270\000" +
    "\270\000\270\000\270\000\210\041\270\000\207" +
    "\051\207\043\210\047\210\021\210\025\210\053" +
    "\210\027\210\023\210\017\210\033\210\057\270" +
    "\000\270\000\270\000\270\000\270\000\270\000" +
    "\270\000\210\055\210\035\210\045\210\037\270" +
    "\000\270\000\270\000\210\061\270\000\270\000" +
    "\270\000\270\000\263\041\270\000\210\051\210" +
    "\043\263\047\263\021\263\025\263\053\263\027" +
    "\263\023\263\017\263\033\263\057\270\000\270" +
    "\000\270\000\270\000\270\000\270\000\270\000" +
    "\263\055\263\035\263\045\263\037\270\000\270" +
    "\000\270\000\263\061\270\000\270\000\270\000" +
    "\270\000\270\000\270\000\263\051\263\043\270" +
    "\000\u0161\267\267\270\267\267\267\267\267\267" +
    "\267\267\267\267\267\267\267\267\267\267\267" +
    "\267\267\267\267\267\267\267\267\267\267\271" +
    "\270\272\267\272\267\344\267\307\267\267\267" +
    "\267\267\267\267\267\267\267\270\267\267\267" +
    "\267\267\267\267\267\346\267\267\267\267\267" +
    "\267\267\267\267\355\322\267\267\267\365\267" +
    "\267\346\267\344\267\267\373\356\267\267\u0100" +
    "\267\267\u010a\271\267\267\267\267\u0108\267\267" +
    "\267\267\267\267\325\267\267\267\267\267\267" +
    "\267\267\267\267\267\312\267\314\361\u0107\267" +
    "\267\267\340\267\271\274\u010c\267\u010f\276\u0114" +
    "\267\337\267\u0116\267\u0102\u0117\267\267\267\267" +
    "\267\267\267\267\267\267\267\267\u0108\267\267" +
    "\267\267\267\267\267\u0118\267\u0125\267\267\267" +
    "\u012b\267\267\267\267\267\u012c\267\267\u0106\267" +
    "\267\267\u0130\267\267\u0127\267\267\267\267\002" +
    "\000\032\000\000\000\000\044\000\221\036\223" +
    "\040\036\224\045\227\000\035\000\064\071\054" +
    "\063\000\050\003\031\000\070\072\165\000\062" +
    "\004\052\065\056\014\014\014\073\006\055\055" +
    "\067\061\103\075\043\125\102\121\110\014\036" +
    "\107\104\113\112\130\076\106\035\036\014\141" +
    "\142\073\137\146\211\071\127\212\126\220\157" +
    "\231\213\070\136\056\014\150\154\152\055\054" +
    "\153\065\050\064\161\175\063\000\164\230\225" +
    "\143\156\213\056\162\160\162\127\065\126\217" +
    "\214\000\014\215\215\161\055\161\233\161\246" +
    "\244\245\264\216\014\226\154\152\055\143\153" +
    "\014\014\232\152\055\055\153\234\247\253\262" +
    "\243\215\265\245\266\000\267\251\000\000\261" +
    "\216\000\000\000\000\000\000\256\000\255\000" +
    "\000\000\243"
    };
  }

  /** Instance of action encapsulation class. */
  protected Action$ action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new Action$(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java.util.Stack<java_cup.runtime.Symbol> stack)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$do_action(act_num, this, stack);
  }


  /** User initialization code. */
  public void user_init() throws java.lang.Exception
    {
 
    ComplexSymbolFactory f = new ComplexSymbolFactory();
    symbolFactory = f;
    lexer = new Lexer(f); 

    }

  /** Scan to get the next Symbol. */
  public java_cup.runtime.Symbol scan()
    throws java.lang.Exception
    {
 
    return lexer.next_token(); 

    }


  Main main;
  emit emit;
  
 /* override error routines */
  protected Lexer lexer;
  public void report_fatal_error(
    String   message,
    Object   info)
    {
      done_parsing();
      if (info instanceof Symbol) ErrorManager.getManager().emit_fatal(message+ "\nCan't recover from previous error(s), giving up.",(Symbol)info);
      else ErrorManager.getManager().emit_fatal(message + "\nCan't recover from previous error(s), giving up.",cur_token);
      System.exit(1);
    }

    public void report_error(String message, Object info)
    {
      if (info instanceof Symbol)
         ErrorManager.getManager().emit_error(message,(Symbol)info);
      else
         ErrorManager.getManager().emit_error(message,cur_token);
    }


/** Cup generated class to encapsulate user supplied action code.*/
static class Action$ {


  /** table of declared symbols -- contains production parts indexed by name */
  private HashMap<String, symbol> symbols = new HashMap<String, symbol>();

  private ArrayList<terminal> terminals = new ArrayList<terminal>();
  private ArrayList<non_terminal> non_terminals = new ArrayList<non_terminal>();
  private ArrayList<production> productions = new ArrayList<production>();

  /** declared start non_terminal */
  private non_terminal start_nt = null;

  /** left hand side non terminal of the current production */
  private non_terminal lhs_nt;

  {
    /* declare "error" and "EOF" as a terminal */
    terminals.add(terminal.error);
    terminals.add(terminal.EOF);
    symbols.put("error", terminal.error);

    /* declare start non terminal */
    non_terminals.add(non_terminal.START_nt);
  }  

  /** Current symbol type */
  String _cur_symbol_type;

  /** Current precedence number */
  int _cur_prec = 0;

  /** Current precedence side */
  int _cur_side = assoc.no_prec;

  /** update the precedences we are declaring */
  protected void update_precedence(int p)
    {
      _cur_side = p;
      _cur_prec++;
    }
  
  private terminal get_term(String id)
    {
      symbol sym = symbols.get(id);

      /* if it wasn't declared of the right type, emit a message */
      if (!(sym instanceof terminal))
	{
	  if (ErrorManager.getManager().getErrorCount() == 0)
	    ErrorManager.getManager().emit_warning("Terminal \"" + id + 
	    "\" has not been declared");
	  return null;
	}
      return (terminal)sym;
    }
  
  private non_terminal get_nonterm(String id)
    {
      symbol sym = symbols.get(id);

      /* if it wasn't declared of the right type, emit a message */
      if (!(sym instanceof non_terminal))
	{
	  if (ErrorManager.getManager().getErrorCount() == 0)
	    ErrorManager.getManager().emit_warning("Non-terminal \"" + id + 
	    "\" has not been declared");
	  return null;
	}
      return (non_terminal)sym;
    }

  /** set start non terminal symbol */
  private void set_start_symbol(non_terminal nt)
    {
      start_nt = nt;
      /* build a special start production */
      symbol_part[] rhs = new symbol_part[2];
      action_part action = null;
      if (start_nt.stack_type() != null)
	{
	  rhs[0] = new symbol_part(start_nt, "start_val");
	  action = new action_part("RESULT = start_val;");
	}
      else
	rhs[0] = new symbol_part(start_nt);
      rhs[1] = new symbol_part(terminal.EOF);
      parser.main.start_production = 
	  new production(0, non_terminal.START_nt, rhs, action, null);
      productions.add(parser.main.start_production);
      non_terminal.START_nt.note_use();
    }
  
  /* . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */

  private int next_nt = 0; 
  non_terminal create_anon_nonterm(String type) 
    {
        non_terminal nt = new non_terminal
        	("NT$" + next_nt++, type, non_terminals.size());
        non_terminals.add(nt);
        return nt;
    }

  /**
   * Create a production. Takes a LHS non terminal, a list of
   * RHS parts (including terminals, non terminals, and actions) and a
   * precedence.  We factor out embedded actions into separate action_production
   * using temporary non-terminals.  Adjacent actions are merge immediately.
   * 
   * <p>Factoring out of actions is accomplished by creating new "hidden" non
   * terminals. For example if the production was originally:</p>
   * 
   * <pre>
   *    A ::= B {action} C D
   * </pre>
   * 
   * then it is factored into two productions:
   * 
   * <pre>
   *    A ::= B X C D
   *    X ::= {action}
   * </pre>
   * 
   * (where X is a unique new non terminal). This has the effect of placing all
   * actions at the end where they can be handled as part of a reduce by the
   * parser.
   */
  private void build_production(non_terminal lhs_sym, ArrayList<production_part> rhs_parts, terminal precedence)
    {
      int i;

      /* make sure we have a valid left-hand-side */
      assert lhs_sym != null : "Attempt to construct a production with a null LHS";

      /* count use of lhs */
      lhs_sym.note_use();
      if (precedence != null)
	precedence.note_use();

      /* merge adjacent actions (if any) */
      Iterator<production_part> it = rhs_parts.iterator();
      action_part prev_action = null;
      while (it.hasNext())
	{
	  production_part part = it.next();
	  if (part instanceof action_part)
	    {
	      if (prev_action != null)
		{
		  prev_action.add_code_string(((action_part)part).code_string());
		  it.remove();
		}
	      else
		prev_action = (action_part) part;
	    }
	  else
	    prev_action = null;
	}
      
      action_part action = null;
      /* strip off any trailing action */
      if (rhs_parts.size() > 0 && rhs_parts.get(rhs_parts.size() - 1).is_action())
	{
	  action = (action_part) rhs_parts.remove(rhs_parts.size()-1);
	}

      /* allocate and copy over the right-hand-side */
      symbol_part[] rhs = new symbol_part[rhs_parts.size()];
      /* count use of each rhs symbol */
      for (i = 0; i < rhs.length; i++)
	{
	  production_part prod = rhs_parts.get(i);
	  if (prod.is_action())
	    {
	      /* create a new non terminal for the action production */
	      non_terminal new_nt = create_anon_nonterm(lhs_sym.stack_type()); 
	      new_nt.is_embedded_action = true;
	      new_nt.note_use();
	      rhs[i] = new symbol_part(new_nt);
	    }
	  else
	    {
	      rhs[i] = (symbol_part) prod;
	    }
	}
      
      /* put the production in the production list of the lhs non terminal */
      production prod = new production(productions.size(), lhs_sym, rhs, action, precedence);
      productions.add(prod);
      int last_act_loc = -1;
      for (i = 0; i < rhs.length; i++)
	{
	  production_part part = rhs_parts.get(i);
	  if (part.is_action())
	    {
	      production actprod = new action_production
	      	(productions.size(), prod, (non_terminal) rhs[i].the_symbol(), 
	      	    (action_part) part, i, last_act_loc);
	      productions.add(actprod);
	      last_act_loc = i;
	    }
	}
    }

  private final parser parser;

  /** Constructor */
  Action$(parser parser) {
    this.parser = parser;
  }

  /** Method with the actual generated action code. */
  @SuppressWarnings({ "unused", "unchecked" })
  public final java_cup.runtime.Symbol CUP$do_action(
    int                        CUP$act_num,
    java_cup.runtime.LRParser  CUP$parser,
    java.util.Stack<java_cup.runtime.Symbol> CUP$stack)
    throws java.lang.Exception
    {
      /* Stack size for peeking into the stack */
      int CUP$size = CUP$stack.size();

      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$result;

      /* select the action based on the action number */
      switch (CUP$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // $START ::= spec EOF 
            {
              Object RESULT = null;
              java_cup.runtime.Symbol start_val$ = CUP$stack.elementAt(CUP$size - 2);
              Grammar start_val = (Grammar) start_val$.value;
RESULT = start_val;
              CUP$result = parser.getSymbolFactory().newSymbol("$START", 0, start_val$, CUP$stack.peek(), RESULT);
            }
          /* ACCEPT */
          CUP$parser.done_parsing();
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // spec ::= package_spec import_list code_parts symbol_list precedence_list start_spec production_list 
            {
              Grammar RESULT = null;
 RESULT = new Grammar(terminals, non_terminals, productions); 
              CUP$result = parser.getSymbolFactory().newSymbol("spec", 35, CUP$stack.elementAt(CUP$size - 7), CUP$stack.peek(), RESULT);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // spec ::= error symbol_list precedence_list start_spec production_list 
            {
              Grammar RESULT = null;
 RESULT = new Grammar(terminals, non_terminals, productions); 
              CUP$result = parser.getSymbolFactory().newSymbol("spec", 35, CUP$stack.elementAt(CUP$size - 5), CUP$stack.peek(), RESULT);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // package_spec ::= PACKAGE multipart_id NT$0 SEMI 
            {
              java_cup.runtime.Symbol id$ = CUP$stack.elementAt(CUP$size - 3);
              StringBuilder id = (StringBuilder) id$.value;
              CUP$result = parser.getSymbolFactory().newSymbol("package_spec", 1, CUP$stack.elementAt(CUP$size - 4), CUP$stack.peek());
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // NT$0 ::= 
            {
              java_cup.runtime.Symbol id$ = CUP$stack.peek();
              StringBuilder id = (StringBuilder) id$.value;

	  /* save the package name */
	  parser.main.setOption("package", id.toString());
	
              CUP$result = parser.getSymbolFactory().newSymbol("NT$0", 50, CUP$stack.elementAt(CUP$size - 2), id$);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // package_spec ::= empty 
            {
              java_cup.runtime.Symbol CUP$sym = CUP$stack.peek();
              CUP$result = parser.getSymbolFactory().newSymbol("package_spec", 1, CUP$sym, CUP$sym);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // import_list ::= import_list import_spec 
            {
              CUP$result = parser.getSymbolFactory().newSymbol("import_list", 2, CUP$stack.elementAt(CUP$size - 2), CUP$stack.peek());
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // import_list ::= empty 
            {
              java_cup.runtime.Symbol CUP$sym = CUP$stack.peek();
              CUP$result = parser.getSymbolFactory().newSymbol("import_list", 2, CUP$sym, CUP$sym);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // import_spec ::= IMPORT import_id SEMI 
            {
              java_cup.runtime.Symbol id$ = CUP$stack.elementAt(CUP$size - 2);
              StringBuilder id = (StringBuilder) id$.value;
 
	  /* save this import on the imports list */
	  parser.emit.import_list.add(id.toString());
	
              CUP$result = parser.getSymbolFactory().newSymbol("import_spec", 16, CUP$stack.elementAt(CUP$size - 3), CUP$stack.peek());
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // code_part ::= option_spec 
            {
              java_cup.runtime.Symbol CUP$sym = CUP$stack.peek();
              CUP$result = parser.getSymbolFactory().newSymbol("code_part", 9, CUP$sym, CUP$sym);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // code_part ::= parser_spec 
            {
              java_cup.runtime.Symbol CUP$sym = CUP$stack.peek();
              CUP$result = parser.getSymbolFactory().newSymbol("code_part", 9, CUP$sym, CUP$sym);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // code_part ::= action_code_part 
            {
              java_cup.runtime.Symbol CUP$sym = CUP$stack.peek();
              CUP$result = parser.getSymbolFactory().newSymbol("code_part", 9, CUP$sym, CUP$sym);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // code_part ::= parser_code_part 
            {
              java_cup.runtime.Symbol CUP$sym = CUP$stack.peek();
              CUP$result = parser.getSymbolFactory().newSymbol("code_part", 9, CUP$sym, CUP$sym);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // code_part ::= init_code 
            {
              java_cup.runtime.Symbol CUP$sym = CUP$stack.peek();
              CUP$result = parser.getSymbolFactory().newSymbol("code_part", 9, CUP$sym, CUP$sym);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // code_part ::= scan_code 
            {
              java_cup.runtime.Symbol CUP$sym = CUP$stack.peek();
              CUP$result = parser.getSymbolFactory().newSymbol("code_part", 9, CUP$sym, CUP$sym);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // code_parts ::= 
            {
              java_cup.runtime.Symbol CUP$sym = CUP$stack.peek();
              CUP$result = parser.getSymbolFactory().newSymbol("code_parts", 8, CUP$sym, CUP$sym);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // code_parts ::= code_parts code_part 
            {
              CUP$result = parser.getSymbolFactory().newSymbol("code_parts", 8, CUP$stack.elementAt(CUP$size - 2), CUP$stack.peek());
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // parser_spec ::= PARSER multipart_id SEMI 
            {
              java_cup.runtime.Symbol name$ = CUP$stack.elementAt(CUP$size - 2);
              StringBuilder name = (StringBuilder) name$.value;
 parser.main.setOption("parser", name.toString()); 
              CUP$result = parser.getSymbolFactory().newSymbol("parser_spec", 3, CUP$stack.elementAt(CUP$size - 3), CUP$stack.peek());
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // parser_spec ::= PARSER multipart_id LT typearglist GT SEMI 
            {
              java_cup.runtime.Symbol types$ = CUP$stack.elementAt(CUP$size - 3);
              String types = (String) types$.value;
              java_cup.runtime.Symbol name$ = CUP$stack.elementAt(CUP$size - 5);
              StringBuilder name = (StringBuilder) name$.value;
 parser.main.setOption("parser", name.toString());
	    parser.main.setOption("typearg", types.toString()); 
              CUP$result = parser.getSymbolFactory().newSymbol("parser_spec", 3, CUP$stack.elementAt(CUP$size - 6), CUP$stack.peek());
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // option_spec ::= OPTION option_list SEMI 
            {
              CUP$result = parser.getSymbolFactory().newSymbol("option_spec", 4, CUP$stack.elementAt(CUP$size - 3), CUP$stack.peek());
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // option_list ::= option_list COMMA option_ 
            {
              CUP$result = parser.getSymbolFactory().newSymbol("option_list", 5, CUP$stack.elementAt(CUP$size - 3), CUP$stack.peek());
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // option_list ::= option_ 
            {
              java_cup.runtime.Symbol CUP$sym = CUP$stack.peek();
              CUP$result = parser.getSymbolFactory().newSymbol("option_list", 5, CUP$sym, CUP$sym);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // option_ ::= robust_id 
            {
              java_cup.runtime.Symbol opt$ = CUP$stack.peek();
              String opt = (String) opt$.value;
 parser.main.setOption(opt); 
              CUP$result = parser.getSymbolFactory().newSymbol("option_", 6, opt$, opt$);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // option_ ::= robust_id EQUALS robust_id 
            {
              java_cup.runtime.Symbol val$ = CUP$stack.peek();
              String val = (String) val$.value;
              java_cup.runtime.Symbol opt$ = CUP$stack.elementAt(CUP$size - 3);
              String opt = (String) opt$.value;
 parser.main.setOption(opt, val); 
              CUP$result = parser.getSymbolFactory().newSymbol("option_", 6, opt$, val$);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // action_code_part ::= ACTION CODE CODE_STRING opt_semi 
            {
              java_cup.runtime.Symbol user_code$ = CUP$stack.elementAt(CUP$size - 2);
              String user_code = (String) user_code$.value;

	  if (parser.emit.action_code!=null)
	    ErrorManager.getManager().emit_warning("Redundant action code (skipping)");
	  else /* save the user included code string */
	    parser.emit.action_code = user_code;
	
              CUP$result = parser.getSymbolFactory().newSymbol("action_code_part", 7, CUP$stack.elementAt(CUP$size - 4), CUP$stack.peek());
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // parser_code_part ::= PARSER CODE CODE_STRING opt_semi 
            {
              java_cup.runtime.Symbol user_code$ = CUP$stack.elementAt(CUP$size - 2);
              String user_code = (String) user_code$.value;

	  if (parser.emit.parser_code!=null)
	    ErrorManager.getManager().emit_warning("Redundant parser code (skipping)");
	  else /* save the user included code string */
	    parser.emit.parser_code = user_code;
	
              CUP$result = parser.getSymbolFactory().newSymbol("parser_code_part", 12, CUP$stack.elementAt(CUP$size - 4), CUP$stack.peek());
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // init_code ::= INIT WITH CODE_STRING opt_semi 
            {
              java_cup.runtime.Symbol user_code$ = CUP$stack.elementAt(CUP$size - 2);
              String user_code = (String) user_code$.value;
 
	  if (parser.emit.init_code!=null)
	    ErrorManager.getManager().emit_warning("Redundant init code (skipping)");
	  else /* save the user code */
	    parser.emit.init_code = user_code;
	
              CUP$result = parser.getSymbolFactory().newSymbol("init_code", 17, CUP$stack.elementAt(CUP$size - 4), CUP$stack.peek());
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // scan_code ::= SCAN WITH CODE_STRING opt_semi 
            {
              java_cup.runtime.Symbol user_code$ = CUP$stack.elementAt(CUP$size - 2);
              String user_code = (String) user_code$.value;
 
	  if (parser.emit.scan_code!=null)
	    ErrorManager.getManager().emit_warning("Redundant scan code (skipping)");
	  else /* save the user code */
	    parser.emit.scan_code = user_code;
	
              CUP$result = parser.getSymbolFactory().newSymbol("scan_code", 18, CUP$stack.elementAt(CUP$size - 4), CUP$stack.peek());
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // symbol_list ::= symbol_list symbol 
            {
              CUP$result = parser.getSymbolFactory().newSymbol("symbol_list", 13, CUP$stack.elementAt(CUP$size - 2), CUP$stack.peek());
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // symbol_list ::= symbol 
            {
              java_cup.runtime.Symbol CUP$sym = CUP$stack.peek();
              CUP$result = parser.getSymbolFactory().newSymbol("symbol_list", 13, CUP$sym, CUP$sym);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // symbol ::= TERMINAL type_id NT$1 declares_term 
            {
              java_cup.runtime.Symbol id$ = CUP$stack.elementAt(CUP$size - 3);
              StringBuilder id = (StringBuilder) id$.value;
 _cur_symbol_type = null; 
              CUP$result = parser.getSymbolFactory().newSymbol("symbol", 19, CUP$stack.elementAt(CUP$size - 4), CUP$stack.peek());
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // NT$1 ::= 
            {
              java_cup.runtime.Symbol id$ = CUP$stack.peek();
              StringBuilder id = (StringBuilder) id$.value;
 _cur_symbol_type = id.toString(); 
              CUP$result = parser.getSymbolFactory().newSymbol("NT$1", 51, CUP$stack.elementAt(CUP$size - 2), id$);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // symbol ::= TERMINAL declares_term 
            {
              CUP$result = parser.getSymbolFactory().newSymbol("symbol", 19, CUP$stack.elementAt(CUP$size - 2), CUP$stack.peek());
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // symbol ::= non_terminal type_id NT$2 declares_non_term 
            {
              java_cup.runtime.Symbol id$ = CUP$stack.elementAt(CUP$size - 3);
              StringBuilder id = (StringBuilder) id$.value;
 _cur_symbol_type = null; 
              CUP$result = parser.getSymbolFactory().newSymbol("symbol", 19, CUP$stack.elementAt(CUP$size - 4), CUP$stack.peek());
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // NT$2 ::= 
            {
              java_cup.runtime.Symbol id$ = CUP$stack.peek();
              StringBuilder id = (StringBuilder) id$.value;
 _cur_symbol_type = id.toString(); 
              CUP$result = parser.getSymbolFactory().newSymbol("NT$2", 52, CUP$stack.elementAt(CUP$size - 2), id$);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // symbol ::= non_terminal declares_non_term 
            {
              CUP$result = parser.getSymbolFactory().newSymbol("symbol", 19, CUP$stack.elementAt(CUP$size - 2), CUP$stack.peek());
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // symbol ::= TERMINAL error SEMI 
            {
 _cur_symbol_type = null; 
              CUP$result = parser.getSymbolFactory().newSymbol("symbol", 19, CUP$stack.elementAt(CUP$size - 3), CUP$stack.peek());
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // symbol ::= non_terminal error SEMI 
            {
 _cur_symbol_type = null; 
              CUP$result = parser.getSymbolFactory().newSymbol("symbol", 19, CUP$stack.elementAt(CUP$size - 3), CUP$stack.peek());
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // declares_term ::= term_name_list SEMI 
            {
              CUP$result = parser.getSymbolFactory().newSymbol("declares_term", 33, CUP$stack.elementAt(CUP$size - 2), CUP$stack.peek());
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // declares_non_term ::= non_term_name_list SEMI 
            {
              CUP$result = parser.getSymbolFactory().newSymbol("declares_non_term", 34, CUP$stack.elementAt(CUP$size - 2), CUP$stack.peek());
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // term_name_list ::= term_name_list COMMA new_term_id 
            {
              CUP$result = parser.getSymbolFactory().newSymbol("term_name_list", 20, CUP$stack.elementAt(CUP$size - 3), CUP$stack.peek());
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // term_name_list ::= new_term_id 
            {
              java_cup.runtime.Symbol CUP$sym = CUP$stack.peek();
              CUP$result = parser.getSymbolFactory().newSymbol("term_name_list", 20, CUP$sym, CUP$sym);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // non_term_name_list ::= non_term_name_list COMMA new_non_term_id 
            {
              CUP$result = parser.getSymbolFactory().newSymbol("non_term_name_list", 21, CUP$stack.elementAt(CUP$size - 3), CUP$stack.peek());
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // non_term_name_list ::= new_non_term_id 
            {
              java_cup.runtime.Symbol CUP$sym = CUP$stack.peek();
              CUP$result = parser.getSymbolFactory().newSymbol("non_term_name_list", 21, CUP$sym, CUP$sym);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // precedence_list ::= precedence_list preced 
            {
              CUP$result = parser.getSymbolFactory().newSymbol("precedence_list", 28, CUP$stack.elementAt(CUP$size - 2), CUP$stack.peek());
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // precedence_list ::= empty 
            {
              java_cup.runtime.Symbol CUP$sym = CUP$stack.peek();
              CUP$result = parser.getSymbolFactory().newSymbol("precedence_list", 28, CUP$sym, CUP$sym);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // preced ::= PRECEDENCE assoc precterminal_list SEMI 
            {
              CUP$result = parser.getSymbolFactory().newSymbol("preced", 29, CUP$stack.elementAt(CUP$size - 4), CUP$stack.peek());
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // assoc ::= LEFT 
            {
 update_precedence(assoc.left); 
              java_cup.runtime.Symbol CUP$sym = CUP$stack.peek();
              CUP$result = parser.getSymbolFactory().newSymbol("assoc", 30, CUP$sym, CUP$sym);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // assoc ::= RIGHT 
            {
 update_precedence(assoc.right); 
              java_cup.runtime.Symbol CUP$sym = CUP$stack.peek();
              CUP$result = parser.getSymbolFactory().newSymbol("assoc", 30, CUP$sym, CUP$sym);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // assoc ::= NONASSOC 
            {
 update_precedence(assoc.nonassoc); 
              java_cup.runtime.Symbol CUP$sym = CUP$stack.peek();
              CUP$result = parser.getSymbolFactory().newSymbol("assoc", 30, CUP$sym, CUP$sym);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // precterminal_list ::= precterminal_list COMMA precterminal_id 
            {
              CUP$result = parser.getSymbolFactory().newSymbol("precterminal_list", 31, CUP$stack.elementAt(CUP$size - 3), CUP$stack.peek());
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // precterminal_list ::= precterminal_id 
            {
              java_cup.runtime.Symbol CUP$sym = CUP$stack.peek();
              CUP$result = parser.getSymbolFactory().newSymbol("precterminal_list", 31, CUP$sym, CUP$sym);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // precterminal_id ::= term_id 
            {
              java_cup.runtime.Symbol term$ = CUP$stack.peek();
              terminal term = (terminal) term$.value;
	
	  term.set_precedence(_cur_side, _cur_prec);
	
              CUP$result = parser.getSymbolFactory().newSymbol("precterminal_id", 32, term$, term$);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // term_id ::= symbol_id 
            {
              terminal RESULT = null;
              java_cup.runtime.Symbol sym$ = CUP$stack.peek();
              String sym = (String) sym$.value;
 RESULT = get_term(sym); 
              CUP$result = parser.getSymbolFactory().newSymbol("term_id", 46, sym$, sym$, RESULT);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // start_spec ::= START WITH symbol_id SEMI 
            {
              java_cup.runtime.Symbol start_name$ = CUP$stack.elementAt(CUP$size - 2);
              String start_name = (String) start_name$.value;
 non_terminal nt = get_nonterm(start_name);
	   if (nt != null) 
	     set_start_symbol(nt); 
	
              CUP$result = parser.getSymbolFactory().newSymbol("start_spec", 14, CUP$stack.elementAt(CUP$size - 4), CUP$stack.peek());
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // start_spec ::= empty 
            {
              java_cup.runtime.Symbol CUP$sym = CUP$stack.peek();
              CUP$result = parser.getSymbolFactory().newSymbol("start_spec", 14, CUP$sym, CUP$sym);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // production_list ::= production_list production 
            {
              CUP$result = parser.getSymbolFactory().newSymbol("production_list", 15, CUP$stack.elementAt(CUP$size - 2), CUP$stack.peek());
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // production_list ::= production 
            {
              java_cup.runtime.Symbol CUP$sym = CUP$stack.peek();
              CUP$result = parser.getSymbolFactory().newSymbol("production_list", 15, CUP$sym, CUP$sym);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // production ::= symbol_id NT$3 COLON_COLON_EQUALS rhs_list SEMI 
            {
              java_cup.runtime.Symbol lhs_id$ = CUP$stack.elementAt(CUP$size - 5);
              String lhs_id = (String) lhs_id$.value;
              CUP$result = parser.getSymbolFactory().newSymbol("production", 22, lhs_id$, CUP$stack.peek());
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // NT$3 ::= 
            {
              java_cup.runtime.Symbol lhs_id$ = CUP$stack.peek();
              String lhs_id = (String) lhs_id$.value;

	  /* lookup the lhs nt */
	  lhs_nt = get_nonterm(lhs_id);
	
              CUP$result = parser.getSymbolFactory().newSymbol("NT$3", 53, lhs_id$, lhs_id$);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // production ::= error NT$4 SEMI 
            {
              CUP$result = parser.getSymbolFactory().newSymbol("production", 22, CUP$stack.elementAt(CUP$size - 3), CUP$stack.peek());
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // NT$4 ::= 
            {
 ErrorManager.getManager().emit_error("Syntax Error"); 
              java_cup.runtime.Symbol CUP$sym = CUP$stack.peek();
              CUP$result = parser.getSymbolFactory().newSymbol("NT$4", 54, CUP$sym, CUP$sym);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // rhs_list ::= rhs_list BAR rhs 
            {
              CUP$result = parser.getSymbolFactory().newSymbol("rhs_list", 25, CUP$stack.elementAt(CUP$size - 3), CUP$stack.peek());
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // rhs_list ::= rhs 
            {
              java_cup.runtime.Symbol CUP$sym = CUP$stack.peek();
              CUP$result = parser.getSymbolFactory().newSymbol("rhs_list", 25, CUP$sym, CUP$sym);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // prod_precedence ::= PERCENT_PREC term_id 
            {
              symbol RESULT = null;
              java_cup.runtime.Symbol term$ = CUP$stack.peek();
              terminal term = (terminal) term$.value;
 RESULT = term; 
              CUP$result = parser.getSymbolFactory().newSymbol("prod_precedence", 49, CUP$stack.elementAt(CUP$size - 2), term$, RESULT);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // prod_precedence ::= empty 
            {
              symbol RESULT = null;
 RESULT = null; 
              java_cup.runtime.Symbol CUP$sym = CUP$stack.peek();
              CUP$result = parser.getSymbolFactory().newSymbol("prod_precedence", 49, CUP$sym, CUP$sym, RESULT);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // rhs ::= prod_part_list prod_precedence 
            {
              java_cup.runtime.Symbol precsym$ = CUP$stack.peek();
              symbol precsym = (symbol) precsym$.value;
              java_cup.runtime.Symbol rhs$ = CUP$stack.elementAt(CUP$size - 2);
              ArrayList<production_part> rhs = (ArrayList<production_part>) rhs$.value;

	  if (lhs_nt != null) 
	    {
	      /* if we have no start non-terminal declared and this is 
		 the first production, make its lhs nt the start_nt 
		 and build a special start production for it. */
	      if (start_nt == null)
		{
		  set_start_symbol(lhs_nt);
		}

	      /* build the production */
	      build_production(lhs_nt, rhs, (terminal) precsym);
	    }
	
              CUP$result = parser.getSymbolFactory().newSymbol("rhs", 26, rhs$, precsym$);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 67: // prod_part_list ::= prod_part_list prod_part 
            {
              ArrayList<production_part> RESULT = null;
              java_cup.runtime.Symbol prod$ = CUP$stack.peek();
              production_part prod = (production_part) prod$.value;
              java_cup.runtime.Symbol list$ = CUP$stack.elementAt(CUP$size - 2);
              ArrayList<production_part> list = (ArrayList<production_part>) list$.value;
 RESULT = list; if (prod != null) RESULT.add(prod); 
              CUP$result = parser.getSymbolFactory().newSymbol("prod_part_list", 48, list$, prod$, RESULT);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 68: // prod_part_list ::= empty 
            {
              ArrayList<production_part> RESULT = null;
 RESULT = new ArrayList<production_part>(); 
              java_cup.runtime.Symbol CUP$sym = CUP$stack.peek();
              CUP$result = parser.getSymbolFactory().newSymbol("prod_part_list", 48, CUP$sym, CUP$sym, RESULT);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 69: // prod_part ::= symbol_id opt_label 
            {
              production_part RESULT = null;
              java_cup.runtime.Symbol labid$ = CUP$stack.peek();
              String labid = (String) labid$.value;
              java_cup.runtime.Symbol symid$ = CUP$stack.elementAt(CUP$size - 2);
              String symid = (String) symid$.value;
 
	  /* try to look up the id */
	  symbol symb = symbols.get(symid);

	  /* if that fails, symbol is undeclared */
	  if (symb == null)
	    {
	      if (ErrorManager.getManager().getErrorCount() == 0)
	        ErrorManager.getManager().emit_error("java_cup.runtime.Symbol \"" + symid + 
			       "\" has not been declared");
	      RESULT = null;
	    }
	  else
	    {
	      /* add a labeled production part */
	      RESULT = new symbol_part(symb, labid);
	    }
	
              CUP$result = parser.getSymbolFactory().newSymbol("prod_part", 47, symid$, labid$, RESULT);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 70: // prod_part ::= CODE_STRING 
            {
              production_part RESULT = null;
              java_cup.runtime.Symbol code_str$ = CUP$stack.peek();
              String code_str = (String) code_str$.value;
 
	  /* add a new production part */
	  RESULT = new action_part(code_str);
	
              CUP$result = parser.getSymbolFactory().newSymbol("prod_part", 47, code_str$, code_str$, RESULT);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 71: // opt_label ::= COLON label_id 
            {
              String RESULT = null;
              java_cup.runtime.Symbol labid$ = CUP$stack.peek();
              String labid = (String) labid$.value;
 RESULT = labid; 
              CUP$result = parser.getSymbolFactory().newSymbol("opt_label", 38, CUP$stack.elementAt(CUP$size - 2), labid$, RESULT);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 72: // opt_label ::= empty 
            {
              String RESULT = null;
 RESULT = null; 
              java_cup.runtime.Symbol CUP$sym = CUP$stack.peek();
              CUP$result = parser.getSymbolFactory().newSymbol("opt_label", 38, CUP$sym, CUP$sym, RESULT);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 73: // multipart_id ::= multipart_id DOT robust_id 
            {
              StringBuilder RESULT = null;
              java_cup.runtime.Symbol another_id$ = CUP$stack.peek();
              String another_id = (String) another_id$.value;
              java_cup.runtime.Symbol id$ = CUP$stack.elementAt(CUP$size - 3);
              StringBuilder id = (StringBuilder) id$.value;
 id.append('.').append(another_id); RESULT=id; 
              CUP$result = parser.getSymbolFactory().newSymbol("multipart_id", 43, id$, another_id$, RESULT);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 74: // multipart_id ::= robust_id 
            {
              StringBuilder RESULT = null;
              java_cup.runtime.Symbol an_id$ = CUP$stack.peek();
              String an_id = (String) an_id$.value;
 RESULT = new StringBuilder(an_id); 
              CUP$result = parser.getSymbolFactory().newSymbol("multipart_id", 43, an_id$, an_id$, RESULT);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 75: // typearglist ::= typeargument 
            {
              String RESULT = null;
              java_cup.runtime.Symbol arg$ = CUP$stack.peek();
              String arg = (String) arg$.value;
 RESULT = arg; 
              CUP$result = parser.getSymbolFactory().newSymbol("typearglist", 40, arg$, arg$, RESULT);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 76: // typearglist ::= typearglist COMMA typeargument 
            {
              String RESULT = null;
              java_cup.runtime.Symbol arg$ = CUP$stack.peek();
              String arg = (String) arg$.value;
              java_cup.runtime.Symbol list$ = CUP$stack.elementAt(CUP$size - 3);
              String list = (String) list$.value;
 RESULT = list + "," + arg; 
              CUP$result = parser.getSymbolFactory().newSymbol("typearglist", 40, list$, arg$, RESULT);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 77: // typeargument ::= type_id 
            {
              String RESULT = null;
              java_cup.runtime.Symbol id$ = CUP$stack.peek();
              StringBuilder id = (StringBuilder) id$.value;
 RESULT = id.toString(); 
              CUP$result = parser.getSymbolFactory().newSymbol("typeargument", 41, id$, id$, RESULT);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 78: // typeargument ::= wildcard 
            {
              String RESULT = null;
              java_cup.runtime.Symbol w$ = CUP$stack.peek();
              String w = (String) w$.value;
 RESULT = w; 
              CUP$result = parser.getSymbolFactory().newSymbol("typeargument", 41, w$, w$, RESULT);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 79: // wildcard ::= QUESTION 
            {
              String RESULT = null;
 RESULT = "?"; 
              java_cup.runtime.Symbol CUP$sym = CUP$stack.peek();
              CUP$result = parser.getSymbolFactory().newSymbol("wildcard", 42, CUP$sym, CUP$sym, RESULT);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 80: // wildcard ::= wildcard EXTENDS type_id 
            {
              String RESULT = null;
              java_cup.runtime.Symbol id$ = CUP$stack.peek();
              StringBuilder id = (StringBuilder) id$.value;
              java_cup.runtime.Symbol w$ = CUP$stack.elementAt(CUP$size - 3);
              String w = (String) w$.value;
 RESULT = w + " extends "+id; 
              CUP$result = parser.getSymbolFactory().newSymbol("wildcard", 42, w$, id$, RESULT);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 81: // wildcard ::= wildcard SUPER type_id 
            {
              String RESULT = null;
              java_cup.runtime.Symbol id$ = CUP$stack.peek();
              StringBuilder id = (StringBuilder) id$.value;
              java_cup.runtime.Symbol w$ = CUP$stack.elementAt(CUP$size - 3);
              String w = (String) w$.value;
 RESULT = w + " super "+id; 
              CUP$result = parser.getSymbolFactory().newSymbol("wildcard", 42, w$, id$, RESULT);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 82: // import_id ::= multipart_id DOT STAR 
            {
              StringBuilder RESULT = null;
              java_cup.runtime.Symbol id$ = CUP$stack.elementAt(CUP$size - 3);
              StringBuilder id = (StringBuilder) id$.value;
 id.append(".*"); RESULT = id; 
              CUP$result = parser.getSymbolFactory().newSymbol("import_id", 44, id$, CUP$stack.peek(), RESULT);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 83: // import_id ::= multipart_id 
            {
              StringBuilder RESULT = null;
              java_cup.runtime.Symbol id$ = CUP$stack.peek();
              StringBuilder id = (StringBuilder) id$.value;
 RESULT = id; 
              CUP$result = parser.getSymbolFactory().newSymbol("import_id", 44, id$, id$, RESULT);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 84: // type_id ::= multipart_id 
            {
              StringBuilder RESULT = null;
              java_cup.runtime.Symbol id$ = CUP$stack.peek();
              StringBuilder id = (StringBuilder) id$.value;
 RESULT = id; 
              CUP$result = parser.getSymbolFactory().newSymbol("type_id", 45, id$, id$, RESULT);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 85: // type_id ::= type_id LBRACK RBRACK 
            {
              StringBuilder RESULT = null;
              java_cup.runtime.Symbol id$ = CUP$stack.elementAt(CUP$size - 3);
              StringBuilder id = (StringBuilder) id$.value;
 id.append("[]"); RESULT = id; 
              CUP$result = parser.getSymbolFactory().newSymbol("type_id", 45, id$, CUP$stack.peek(), RESULT);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 86: // type_id ::= multipart_id LT typearglist GT 
            {
              StringBuilder RESULT = null;
              java_cup.runtime.Symbol types$ = CUP$stack.elementAt(CUP$size - 2);
              String types = (String) types$.value;
              java_cup.runtime.Symbol id$ = CUP$stack.elementAt(CUP$size - 4);
              StringBuilder id = (StringBuilder) id$.value;
 id.append('<').append(types).append('>');
            RESULT=id; 
              CUP$result = parser.getSymbolFactory().newSymbol("type_id", 45, id$, CUP$stack.peek(), RESULT);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 87: // new_term_id ::= symbol_id 
            {
              java_cup.runtime.Symbol term_id$ = CUP$stack.peek();
              String term_id = (String) term_id$.value;
 
	  /* see if this terminal has been declared before */
	  if (symbols.get(term_id) != null)
	    {
	      /* issue a message */
	      ErrorManager.getManager().emit_error("Symbol \"" + term_id + 
			   "\" has already been declared");
	    }
	  else
	    {
	      /* build a production_part and put it in the table */
	      terminal term = new terminal(term_id, _cur_symbol_type, terminals.size());
	      terminals.add(term);
	      symbols.put(term_id, term);
	    }
	
              CUP$result = parser.getSymbolFactory().newSymbol("new_term_id", 23, term_id$, term_id$);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 88: // new_non_term_id ::= symbol_id 
            {
              java_cup.runtime.Symbol non_term_id$ = CUP$stack.peek();
              String non_term_id = (String) non_term_id$.value;
 
	  /* see if this non terminal has been declared before */
	  if (symbols.get(non_term_id) != null)
	    {
	      /* issue a message */
	      ErrorManager.getManager().emit_error( "Symbol \"" + non_term_id + 
			                      "\" has already been declared");
	    }
	  else
	    {
	      /* build the non terminal object */
              non_terminal this_nt = 
		new non_terminal(non_term_id, _cur_symbol_type, non_terminals.size());
	      non_terminals.add(this_nt);

	      /* put it in the symbols table */ 
	      symbols.put(non_term_id, this_nt);
	    }
	
              CUP$result = parser.getSymbolFactory().newSymbol("new_non_term_id", 24, non_term_id$, non_term_id$);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 89: // symbol_id ::= ID 
            {
              String RESULT = null;
              java_cup.runtime.Symbol the_id$ = CUP$stack.peek();
              String the_id = (String) the_id$.value;
 RESULT = the_id; 
              CUP$result = parser.getSymbolFactory().newSymbol("symbol_id", 36, the_id$, the_id$, RESULT);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 90: // symbol_id ::= SUPER 
            {
              String RESULT = null;
 RESULT = "super"; 
              java_cup.runtime.Symbol CUP$sym = CUP$stack.peek();
              CUP$result = parser.getSymbolFactory().newSymbol("symbol_id", 36, CUP$sym, CUP$sym, RESULT);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 91: // symbol_id ::= EXTENDS 
            {
              String RESULT = null;
 RESULT = "extends"; 
              java_cup.runtime.Symbol CUP$sym = CUP$stack.peek();
              CUP$result = parser.getSymbolFactory().newSymbol("symbol_id", 36, CUP$sym, CUP$sym, RESULT);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 92: // label_id ::= robust_id 
            {
              String RESULT = null;
              java_cup.runtime.Symbol the_id$ = CUP$stack.peek();
              String the_id = (String) the_id$.value;
 RESULT = the_id; 
              CUP$result = parser.getSymbolFactory().newSymbol("label_id", 37, the_id$, the_id$, RESULT);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 93: // robust_id ::= ID 
            {
              String RESULT = null;
              java_cup.runtime.Symbol the_id$ = CUP$stack.peek();
              String the_id = (String) the_id$.value;
 RESULT = the_id; 
              CUP$result = parser.getSymbolFactory().newSymbol("robust_id", 39, the_id$, the_id$, RESULT);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 94: // robust_id ::= OPTION 
            {
              String RESULT = null;
 RESULT = "option"; 
              java_cup.runtime.Symbol CUP$sym = CUP$stack.peek();
              CUP$result = parser.getSymbolFactory().newSymbol("robust_id", 39, CUP$sym, CUP$sym, RESULT);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 95: // robust_id ::= CODE 
            {
              String RESULT = null;
 RESULT = "code"; 
              java_cup.runtime.Symbol CUP$sym = CUP$stack.peek();
              CUP$result = parser.getSymbolFactory().newSymbol("robust_id", 39, CUP$sym, CUP$sym, RESULT);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 96: // robust_id ::= ACTION 
            {
              String RESULT = null;
 RESULT = "action"; 
              java_cup.runtime.Symbol CUP$sym = CUP$stack.peek();
              CUP$result = parser.getSymbolFactory().newSymbol("robust_id", 39, CUP$sym, CUP$sym, RESULT);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 97: // robust_id ::= PARSER 
            {
              String RESULT = null;
 RESULT = "parser"; 
              java_cup.runtime.Symbol CUP$sym = CUP$stack.peek();
              CUP$result = parser.getSymbolFactory().newSymbol("robust_id", 39, CUP$sym, CUP$sym, RESULT);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 98: // robust_id ::= TERMINAL 
            {
              String RESULT = null;
 RESULT = "terminal"; 
              java_cup.runtime.Symbol CUP$sym = CUP$stack.peek();
              CUP$result = parser.getSymbolFactory().newSymbol("robust_id", 39, CUP$sym, CUP$sym, RESULT);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 99: // robust_id ::= NON 
            {
              String RESULT = null;
 RESULT = "non"; 
              java_cup.runtime.Symbol CUP$sym = CUP$stack.peek();
              CUP$result = parser.getSymbolFactory().newSymbol("robust_id", 39, CUP$sym, CUP$sym, RESULT);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 100: // robust_id ::= NONTERMINAL 
            {
              String RESULT = null;
 RESULT = "nonterminal"; 
              java_cup.runtime.Symbol CUP$sym = CUP$stack.peek();
              CUP$result = parser.getSymbolFactory().newSymbol("robust_id", 39, CUP$sym, CUP$sym, RESULT);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 101: // robust_id ::= INIT 
            {
              String RESULT = null;
 RESULT = "init"; 
              java_cup.runtime.Symbol CUP$sym = CUP$stack.peek();
              CUP$result = parser.getSymbolFactory().newSymbol("robust_id", 39, CUP$sym, CUP$sym, RESULT);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 102: // robust_id ::= SCAN 
            {
              String RESULT = null;
 RESULT = "scan"; 
              java_cup.runtime.Symbol CUP$sym = CUP$stack.peek();
              CUP$result = parser.getSymbolFactory().newSymbol("robust_id", 39, CUP$sym, CUP$sym, RESULT);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 103: // robust_id ::= WITH 
            {
              String RESULT = null;
 RESULT = "with"; 
              java_cup.runtime.Symbol CUP$sym = CUP$stack.peek();
              CUP$result = parser.getSymbolFactory().newSymbol("robust_id", 39, CUP$sym, CUP$sym, RESULT);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 104: // robust_id ::= START 
            {
              String RESULT = null;
 RESULT = "start"; 
              java_cup.runtime.Symbol CUP$sym = CUP$stack.peek();
              CUP$result = parser.getSymbolFactory().newSymbol("robust_id", 39, CUP$sym, CUP$sym, RESULT);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 105: // robust_id ::= PRECEDENCE 
            {
              String RESULT = null;
 RESULT = "precedence"; 
              java_cup.runtime.Symbol CUP$sym = CUP$stack.peek();
              CUP$result = parser.getSymbolFactory().newSymbol("robust_id", 39, CUP$sym, CUP$sym, RESULT);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 106: // robust_id ::= LEFT 
            {
              String RESULT = null;
 RESULT = "left"; 
              java_cup.runtime.Symbol CUP$sym = CUP$stack.peek();
              CUP$result = parser.getSymbolFactory().newSymbol("robust_id", 39, CUP$sym, CUP$sym, RESULT);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 107: // robust_id ::= RIGHT 
            {
              String RESULT = null;
 RESULT = "right"; 
              java_cup.runtime.Symbol CUP$sym = CUP$stack.peek();
              CUP$result = parser.getSymbolFactory().newSymbol("robust_id", 39, CUP$sym, CUP$sym, RESULT);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 108: // robust_id ::= NONASSOC 
            {
              String RESULT = null;
 RESULT = "nonassoc"; 
              java_cup.runtime.Symbol CUP$sym = CUP$stack.peek();
              CUP$result = parser.getSymbolFactory().newSymbol("robust_id", 39, CUP$sym, CUP$sym, RESULT);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 109: // robust_id ::= error 
            {
              String RESULT = null;

		ErrorManager.getManager().emit_error("Illegal use of reserved word");
		RESULT="ILLEGAL";
	
              java_cup.runtime.Symbol CUP$sym = CUP$stack.peek();
              CUP$result = parser.getSymbolFactory().newSymbol("robust_id", 39, CUP$sym, CUP$sym, RESULT);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 110: // non_terminal ::= NON TERMINAL 
            {
              CUP$result = parser.getSymbolFactory().newSymbol("non_terminal", 11, CUP$stack.elementAt(CUP$size - 2), CUP$stack.peek());
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 111: // non_terminal ::= NONTERMINAL 
            {
              java_cup.runtime.Symbol CUP$sym = CUP$stack.peek();
              CUP$result = parser.getSymbolFactory().newSymbol("non_terminal", 11, CUP$sym, CUP$sym);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 112: // opt_semi ::= 
            {
              java_cup.runtime.Symbol CUP$sym = CUP$stack.peek();
              CUP$result = parser.getSymbolFactory().newSymbol("opt_semi", 10, CUP$sym, CUP$sym);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 113: // opt_semi ::= SEMI 
            {
              java_cup.runtime.Symbol CUP$sym = CUP$stack.peek();
              CUP$result = parser.getSymbolFactory().newSymbol("opt_semi", 10, CUP$sym, CUP$sym);
            }
          return CUP$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 114: // empty ::= 
            {
              java_cup.runtime.Symbol CUP$sym = CUP$stack.peek();
              CUP$result = parser.getSymbolFactory().newSymbol("empty", 27, CUP$sym, CUP$sym);
            }
          return CUP$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number found in internal parse table");

        }
    }
}

}
